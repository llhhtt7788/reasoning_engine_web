
---

# PRD v1.7.2

## Intent-aware Context Architecture · Phase 1 Stable

**版本号**：v1.7.2
**状态**：Ready for Development / Stable Iteration
**依赖版本**：v1.7.0 / v1.7.1
**适用模块**：LangGraph / ContextEngine / Chat Service
**定位**：

> 将 Intent-aware Context 从“概念 + 骨架”推进为 **真实可运行、可配置、可观测、可灰度** 的第一阶段稳定版本。

---

## 0. 为什么是 v1.7.2（而不是 1.7.1）

在 v1.7.x 系列中：

* **v1.7.0**：架构设计与方向确认
* **v1.7.1**：工程骨架 + 策略概念验证
* **v1.7.2**：

  * 明确 **执行顺序与工程优先级**
  * 明确 **Intent / Policy 的可配置边界**
  * 明确 **Context 是否使用的唯一真源**
  * 明确 **前后端契约稳定点**

👉 v1.7.2 是**可以长期维护和向前扩展的基线版本**。

---

## 1. 背景与问题重述

当前上下文“关联不上”的根因并非 Embedding / Recall 本身，而是：

> 系统**没有一个显式、可观测、可配置的控制流**来决定：
>
> * 这轮对话 **是否应该使用上下文**
> * 使用哪些上下文能力（recall / rerank / memory write）
> * 为什么被跳过 / 被使用

v1.7.2 的目标是让系统从
**“隐式猜测是否用上下文” → “显式意图 + 策略驱动”**

---

## 2. 版本目标与边界

### 2.1 v1.7.2 必须达成的目标（Must）

1. **Intent → Policy → Execution 全链路真实执行**
2. **LangGraph DAG 中显式出现“是否使用上下文”的分支**
3. **ContextEngine assemble 行为真正受策略开关控制**
4. **context_debug 成为唯一可信决策解释源**
5. **支持通过配置扩展 intent 与策略，不改代码**

---

### 2.2 明确不在 v1.7.2 做的事（Not In Scope）

* ❌ 不追求意图分类准确率最优
* ❌ 不引入自动学习 / 反馈闭环
* ❌ 不做离线任务（tagging / decay / summarization）
* ❌ 不改变主对话 UI 结构
* ❌ 不强制新数据库 schema

---

## 3. 核心概念（v1.7.2 定义）

### 3.1 Intent（意图）

**定义**：
对“当前用户输入 + 最近上下文”的高层语义判断，用于指导是否需要上下文能力。

Intent 是 **控制流信号，不是业务语义标签**。

最低支持意图（MVP）：

| Intent        | 含义           |
| ------------- | ------------ |
| qa_contextual | 明确依赖上下文 / 记忆 |
| qa_stateless  | 单轮即可回答       |
| unknown       | 兜底           |

---

### 3.2 Context Strategy（上下文策略）

**定义**：
由 Intent 映射而来的、对 ContextEngine 的执行指令集合。

```json
{
  "use_context": true,
  "recall_enabled": true,
  "rerank_enabled": true,
  "write_memory": "auto",
  "keep_recent_turns": 2,
  "recall_top_k": 20,
  "rerank_threshold": 0.75
}
```

---

### 3.3 Context Execution（执行结论）

**唯一真源**，用于前端和调试判断：

```json
{
  "mode": "used | skipped",
  "skip_reason": "policy_use_context_false",
  "keep_recent_turns": 1
}
```

⚠️ **禁止通过 recalled_count == 0 推断 skipped**

---

## 4. LangGraph DAG（v1.7.2）

```
IDGuard
  ↓
TaskClassifier
  ↓
IntentClassifierNode
  ↓
ContextPolicyNode
  ├── use_context = false → SkipContextNode → LLM
  └── use_context = true  → ContextEngineNode → LLM
        ↓
PostAnswerSanitizer
  ↓
MemoryWriter (optional, policy-controlled)
```

### 新增节点职责

| Node                 | 职责                    |
| -------------------- | --------------------- |
| IntentClassifierNode | 只负责意图判断               |
| ContextPolicyNode    | 只负责 intent → strategy |
| SkipContextNode      | 显式跳过上下文并填充 debug      |
| ContextEngineNode    | 只执行策略指令               |

---

## 5. 后端功能需求

### 5.1 IntentClassifierNode（v1.7.2 要求）

* 支持独立 Intent LLM（INTENT_LLM_*）
* 未配置时 fallback 到 llm_fast
* 输出结构稳定：

```json
"intent": {
  "type": "qa_stateless",
  "confidence": 0.62,
  "source": "intent_llm | fallback",
  "model": "llama3-8b-int8"
}
```

---

### 5.2 ContextPolicyNode（配置驱动）

策略来源：`config/intent_policies.yaml`

#### 最低要求配置示例

```yaml
default:
  use_context: true
  recall_enabled: true
  rerank_enabled: true
  write_memory: auto
  keep_recent_turns: 2

qa_stateless:
  use_context: false
  recall_enabled: false
  rerank_enabled: false
  write_memory: off
  keep_recent_turns: 1

qa_contextual:
  use_context: true
  recall_enabled: true
  rerank_enabled: true
  write_memory: auto
  keep_recent_turns: 2
```

**规则**：

* intent 未命中 → default
* 配置缺失 → default + debug 标记

---

### 5.3 SkipContextNode（显式跳过）

* 不调用 ContextEngine
* recent_turns 按 keep_recent_turns 保留
* memory_selected = []
* context_execution.mode = skipped
* 必须写 skip_reason

---

### 5.4 ContextEngine assemble 开关（强约束）

| 参数                   | 行为                  |
| -------------------- | ------------------- |
| recall_enabled=false | 不调用 recall          |
| rerank_enabled=false | 不调用 rerank          |
| use_context=true     | execution.mode=used |
| use_context=false    | 不进入 Engine          |

⚠️ **assemble 必须真实遵守开关，不只是写 debug**

---

## 6. 对外接口（Chat API）

### /api/v1/chat/context（增量）

```json
"context_debug": {
  "intent": {...},
  "context_strategy": {...},
  "context_execution": {...},
  "context_backends": {...},
  "memory_selected": [...]
}
```

**稳定性要求**：

* 字段存在即可，值可为空
* 绝不返回 unknown 作为执行结论

---

## 7. 可观测性与调试

### LangGraph Path

* 必须可见：

  * intent_classifier
  * context_policy
  * skip_context（条件出现）

### 日志最小要求

* turn_id / session_id
* intent.type
* strategy.use_context
* execution.mode

---

## 8. 验收标准（DoD）

* [ ] qa_contextual → ContextEngine 路径真实执行
* [ ] qa_stateless → SkipContextNode 路径真实执行
* [ ] context_execution.mode 唯一可信
* [ ] intent / strategy / execution 全部可观测
* [ ] 不破坏现有 SSE / LangGraph 回放
* [ ] 未配置 intent LLM 仍可运行

---

## 9. 开发顺序建议（v1.7.2）

**推荐顺序（非常重要）**：

1. **ContextEngine assemble 开关生效**
2. IntentClassifierNode 骨架
3. ContextPolicyNode + yaml loader
4. SkipContextNode
5. LangGraph 路由接线
6. E2E 测试（contextual / stateless）

> 原因：
> **Engine 行为正确 → DAG 接线才有意义**

---

## 10. 风险与降级

| 风险             | 降级策略              |
| -------------- | ----------------- |
| Intent LLM 不可用 | fallback llm_fast |
| yaml 缺失        | default policy    |
| 任一节点异常         | 不阻断聊天主流程          |
| 策略错误           | debug 可见、可回滚      |

---

## 11. 一句话总结（v1.7.2）

> **v1.7.2 是 Context Engine 从“猜测是否用上下文”迈向“意图驱动、策略可控、工程可治理”的第一个稳定版本。**

---